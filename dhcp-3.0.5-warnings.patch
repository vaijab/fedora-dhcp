--- dhcp-3.0.5/client/dhclient.c.warnings	2006-08-22 11:13:57.000000000 -0400
+++ dhcp-3.0.5/client/dhclient.c	2007-03-29 14:23:54.000000000 -0400
@@ -95,7 +95,6 @@
 	omapi_object_t *listener;
 	isc_result_t result;
 	int persist = 0;
-	int omapi_port;
 	int no_dhclient_conf = 0;
 	int no_dhclient_db = 0;
 	int no_dhclient_pid = 0;
@@ -634,7 +633,6 @@
 			picked = lp;
 			picked -> next = (struct client_lease *)0;
 		} else {
-		      freeit:
 			destroy_client_lease (lp);
 		}
 	}
@@ -693,7 +691,6 @@
 	struct client_lease *lease;
 	struct option_cache *oc;
 	struct data_string ds;
-	int i;
 	
 	/* If we're not receptive to an offer right now, or if the offer
 	   has an unrecognizable transaction id, then just drop it. */
@@ -845,8 +842,6 @@
 void bind_lease (client)
 	struct client_state *client;
 {
-	struct interface_info *ip = client -> interface;
-
 	/* Remember the medium. */
 	client -> new -> medium = client -> medium;
 
@@ -911,7 +906,6 @@
 	void *cpp;
 {
 	struct client_state *client = cpp;
-	int i;
 	struct option_cache *oc;
 	struct data_string ds;
 
@@ -954,7 +948,6 @@
 	void *cpp;
 {
 	struct client_state *client = cpp;
-	int i;
 
 	/* Cancel all timeouts. */
 	cancel_timeout (state_selecting, client);
@@ -1067,8 +1060,6 @@
 	int i;
 	int stop_selecting;
 	const char *name = packet -> packet_type ? "DHCPOFFER" : "BOOTREPLY";
-	struct iaddrlist *ap;
-	struct option_cache *oc;
 	char obuf [1024];
 	
 #ifdef DEBUG_PACKET
@@ -1886,7 +1877,6 @@
 	struct client_lease *lease;
 {
 	unsigned char discover = DHCPDISCOVER;
-	int i;
 	struct option_state *options = (struct option_state *)0;
 
 	memset (&client -> packet, 0, sizeof (client -> packet));
@@ -1950,9 +1940,6 @@
 	struct client_lease *lease;
 {
 	unsigned char request = DHCPREQUEST;
-	int i, j;
-	unsigned char *tmp, *digest;
-	unsigned char *old_digest_loc;
 	struct option_cache *oc;
 
 	memset (&client -> packet, 0, sizeof (client -> packet));
@@ -2040,7 +2027,6 @@
 	struct client_lease *lease;
 {
 	unsigned char decline = DHCPDECLINE;
-	int i;
 	struct option_cache *oc;
 
 	struct option_state *options = (struct option_state *)0;
@@ -2096,7 +2082,6 @@
 	struct client_lease *lease;
 {
 	unsigned char request = DHCPRELEASE;
-	int i;
 	struct option_cache *oc;
 
 	struct option_state *options = (struct option_state *)0;
@@ -2153,8 +2138,6 @@
 void destroy_client_lease (lease)
 	struct client_lease *lease;
 {
-	int i;
-
 	if (lease -> server_name)
 		dfree (lease -> server_name, MDL);
 	if (lease -> filename)
@@ -2217,8 +2200,6 @@
 {
 	const char *name, *dot;
 	struct data_string ds;
-	int status;
-	struct client_state *client;
 
 	memset (&ds, 0, sizeof ds);
 
@@ -2249,9 +2230,7 @@
 	int i;
 	struct tm *t;
 	static int leases_written;
-	struct option_cache *oc;
 	struct data_string ds;
-	pair *hash;
 	int errors = 0;
 	char *s;
 
@@ -2487,8 +2466,6 @@
 	int i;
 	struct data_string data;
 	struct option_cache *oc;
-	pair *hash;
-	char *s, *t;
 	struct envadd_state es;
 
 	es.client = client;
@@ -2565,11 +2542,9 @@
 int script_go (client)
 	struct client_state *client;
 {
-	int rval;
 	char *scriptName;
 	char *argv [2];
 	char **envp;
-	char *epp [3];
 	char reason [] = "REASON=NBI";
 	static char client_path [] = CLIENT_PATH;
 	int i;
@@ -2645,7 +2620,7 @@
 {
 	char spbuf [1024];
 	char *s;
-	unsigned len, i;
+	unsigned len;
 	struct string_list *val;
 	va_list list;
 
@@ -3071,8 +3046,7 @@
 
 isc_result_t client_dns_update (struct client_state *client, int addp, int ttl)
 {
-	struct data_string ddns_fqdn, ddns_fwd_name,
-	       ddns_dhcid, client_identifier;
+	struct data_string ddns_fwd_name, ddns_dhcid, client_identifier;
 	struct option_cache *oc;
 	int ignorep;
 	int result;
--- dhcp-3.0.5/client/clparse.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/client/clparse.c	2007-03-29 14:24:47.000000000 -0400
@@ -39,8 +39,6 @@
 
 #include "dhcpd.h"
 
-static TIME parsed_time;
-
 struct client_config top_level_config;
 
 u_int32_t default_requested_options [] = {
@@ -62,7 +60,6 @@
 isc_result_t read_client_conf ()
 {
 	struct client_config *config;
-	struct client_state *state;
 	struct interface_info *ip;
 	isc_result_t status;
 
@@ -240,11 +237,9 @@
 	int token;
 	const char *val;
 	struct option *option;
-	struct executable_statement *stmt, **p;
-	enum statement_op op;
+	struct executable_statement *stmt;
 	int lose;
 	char *name;
-	struct data_string key_id;
 	enum policy policy;
 	int known;
 	int tmp, i;
@@ -967,11 +962,9 @@
 {
 	int token;
 	const char *val;
-	char *t, *n;
 	struct interface_info *ip;
 	struct option_cache *oc;
 	struct client_state *client = (struct client_state *)0;
-	struct data_string key_id;
 
 	switch (next_token (&val, (unsigned *)0, cfile)) {
 	      case KEY:
@@ -1162,12 +1155,6 @@
 	struct parse *cfile;
 	int flag;
 {
-	enum dhcp_token token;
-	const char *val;
-	unsigned char rf = flag;
-	struct expression *data = (struct expression *)0;
-	int status;
-
 	parse_warn (cfile, "allow/deny/ignore not permitted here.");
 	skip_to_semi (cfile);
 	return 0;
--- dhcp-3.0.5/common/parse.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/parse.c	2007-03-29 13:45:34.000000000 -0400
@@ -311,9 +311,6 @@
 	struct parse *cfile;
 	struct iaddr *addr;
 {
-	const char *val;
-	enum dhcp_token token;
-
 	addr -> len = 4;
 	if (parse_numeric_aggregate (cfile, addr -> iabuf,
 				     &addr -> len, DOT, 10, 8))
@@ -650,7 +647,6 @@
 TIME parse_date (cfile)
 	struct parse *cfile;
 {
-	struct tm tm;
 	int guess;
 	int tzoff, wday, year, mon, mday, hour, min, sec;
 	const char *val;
@@ -1022,7 +1018,6 @@
 	char tokbuf [128];
 	unsigned tokix = 0;
 	char type;
-	int code;
 	int is_signed;
 	char *s;
 	int has_encapsulation = 0;
@@ -1511,7 +1506,6 @@
 {
 	enum dhcp_token token;
 	const char *val;
-	struct executable_statement base;
 	struct class *cta;
 	struct option *option;
 	struct option_cache *cache;
@@ -1814,7 +1808,6 @@
 		if (token != NAME && token != NUMBER_OR_NAME) {
 			parse_warn (cfile,
 				    "%s can't be a variable name", val);
-		      badunset:
 			skip_to_semi (cfile);
 			*lose = 1;
 			return 0;
@@ -2789,16 +2782,12 @@
 	enum dhcp_token token;
 	const char *val;
 	struct collection *col;
-	struct option *option;
 	struct expression *nexp, **ep;
 	int known;
 	enum expr_op opcode;
 	const char *s;
 	char *cptr;
-	struct executable_statement *stmt;
-	int i;
 	unsigned long u;
-	isc_result_t status, code;
 	unsigned len;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
@@ -3286,7 +3275,6 @@
 					parse_warn
 						(cfile,
 						 "expecting dns expression.");
-			      badnstrans:
 				expression_dereference (expr, MDL);
 				*lose = 1;
 				return 0;
@@ -4194,8 +4182,6 @@
 	struct expression *expr = (struct expression *)0;
 	struct expression *tmp;
 	int lose;
-	struct executable_statement *stmt;
-	int ftt = 1;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
 	if (token == SEMI) {
@@ -4313,9 +4299,7 @@
 	struct expression *t = (struct expression *)0;
 	unsigned char buf [4];
 	unsigned len;
-	unsigned char *ob;
 	struct iaddr addr;
-	int num;
 	const char *f, *g;
 	struct enumeration_value *e;
 
@@ -4556,8 +4540,6 @@
 		/* Set a flag if this is an array of a simple type (i.e.,
 		   not an array of pairs of IP addresses, or something
 		   like that. */
-		int uniform = option -> format [1] == 'A';
-
 		for (fmt = option -> format; *fmt; fmt++) {
 			if (*fmt == 'A')
 				break;
@@ -4756,7 +4738,6 @@
 	int token;
 	const char *val;
 	unsigned len;
-	u_int8_t *s;
 
 	token = peek_token (&val, (unsigned *)0, cfile);
 	if (token == NUMBER_OR_NAME || token == NUMBER) {
@@ -4823,9 +4804,10 @@
 		if (lix < (sizeof lexbuf) - 1)
 			lexbuf [lix++] = ' ';
 		if (cfile -> token_line [i] == '\t') {
-			for (lix;
-			     lix < (sizeof lexbuf) - 1 && (lix & 7); lix++)
+			while (lix < (sizeof lexbuf) - 1 && (lix & 7)) {
 				lexbuf [lix] = ' ';
+				lix++;
+			}
 		}
 	}
 	lexbuf [lix] = 0;
@@ -4838,14 +4820,20 @@
 #endif
 
 	if (log_perror) {
-		write (STDERR_FILENO, mbuf, strlen (mbuf));
-		write (STDERR_FILENO, "\n", 1);
-		write (STDERR_FILENO, cfile -> token_line,
-		       strlen (cfile -> token_line));
-		write (STDERR_FILENO, "\n", 1);
+		if (write (STDERR_FILENO, mbuf, strlen (mbuf)) <= 0)
+			return -1;
+		if (write (STDERR_FILENO, "\n", 1) <= 0)
+			return -1;
+		if (write (STDERR_FILENO, cfile -> token_line,
+		       strlen (cfile -> token_line)) <= 0)
+			return -1;
+		if (write (STDERR_FILENO, "\n", 1) <= 0)
+			return -1;
 		if (cfile -> lexchar < 81)
-			write (STDERR_FILENO, lexbuf, lix);
-		write (STDERR_FILENO, "^\n", 2);
+			if (write (STDERR_FILENO, lexbuf, lix) <= 0)
+				return -1;
+		if (write (STDERR_FILENO, "^\n", 2) <= 0)
+			return -1;
 	}
 
 	cfile -> warnings_occurred = 1;
--- dhcp-3.0.5/common/icmp.c.warnings	2004-06-10 13:59:18.000000000 -0400
+++ dhcp-3.0.5/common/icmp.c	2007-03-29 13:45:34.000000000 -0400
@@ -61,11 +61,7 @@
 {
 	struct protoent *proto;
 	int protocol = 1;
-	struct sockaddr_in from;
-	int fd;
 	int state;
-	struct icmp_state *new;
-	omapi_object_t *h;
 	isc_result_t result;
 
 	/* Only initialize icmp once. */
@@ -284,7 +280,6 @@
 void trace_icmp_input_input (trace_type_t *ttype, unsigned length, char *buf)
 {
 	struct iaddr *ia;
-	unsigned len;
 	u_int8_t *icbuf;
 	ia = (struct iaddr *)buf;
 	ia->len = ntohl(ia->len);
--- dhcp-3.0.5/common/socket.c.warnings	2004-06-10 13:59:21.000000000 -0400
+++ dhcp-3.0.5/common/socket.c	2007-03-29 13:45:34.000000000 -0400
@@ -55,8 +55,6 @@
 # endif
 #endif
 
-static int once = 0;
-
 /* Reinitializes the specified interface after an address change.   This
    is not required for packet-filter APIs. */
 
--- dhcp-3.0.5/common/lpf.c.warnings	2004-11-24 12:39:15.000000000 -0500
+++ dhcp-3.0.5/common/lpf.c	2007-03-29 13:45:34.000000000 -0400
@@ -69,8 +69,6 @@
 	struct interface_info *info;
 {
 	int sock;
-	char filename[50];
-	int b;
 	struct sockaddr sa;
 
 	/* Make an LPF socket. */
@@ -334,7 +332,6 @@
 	struct sockaddr_in *from;
 	struct hardware *hfrom;
 {
-	int nread;
 	int length = 0;
 	int offset = 0;
 	unsigned char ibuf [1536];
--- dhcp-3.0.5/common/memory.c.warnings	2004-06-10 13:59:19.000000000 -0400
+++ dhcp-3.0.5/common/memory.c	2007-03-29 13:45:34.000000000 -0400
@@ -84,8 +84,7 @@
 
 isc_result_t supersede_group (struct group_object *group, int writep)
 {
-	struct group_object *t, *u;
-	isc_result_t status;
+	struct group_object *t;
 
 	/* Register the group in the group name hash table,
 	   so we can look it up later. */
@@ -142,7 +141,6 @@
 int clone_group (struct group **gp, struct group *group,
 		 const char *file, int line)
 {
-	isc_result_t status;
 	struct group *g = (struct group *)0;
 
 	/* Normally gp should contain the null pointer, but for convenience
--- dhcp-3.0.5/common/print.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/print.c	2007-03-29 13:45:34.000000000 -0400
@@ -1043,7 +1043,6 @@
 			       const char *suffix, ...)
 {
 	va_list list;
-	char *buf;
 	unsigned len;
 	char *s, *t, *u;
 
@@ -1081,7 +1080,6 @@
 			      struct data_string *data)
 {
 	int i;
-	char *buf;
 	char obuf [3];
 
 	/* See if this is just ASCII. */
--- dhcp-3.0.5/common/options.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/options.c	2007-03-29 13:45:34.000000000 -0400
@@ -43,16 +43,11 @@
 
 struct option *vendor_cfg_option;
 
-static void do_option_set PROTO ((pair *,
-				  struct option_cache *,
-				  enum statement_op));
-
 /* Parse all available options out of the specified packet. */
 
 int parse_options (packet)
 	struct packet *packet;
 {
-	int i;
 	struct option_cache *op = (struct option_cache *)0;
 
 	/* Allocate a new option state. */
@@ -112,8 +107,6 @@
 	unsigned length;
 	struct universe *universe;
 {
-	unsigned char *t;
-	const unsigned char *end = buffer + length;
 	unsigned len, offset;
 	int code;
 	struct option_cache *op = (struct option_cache *)0;
@@ -277,7 +270,6 @@
 			  const unsigned char *buffer,
 			  unsigned length, struct universe *u)
 {
-	char *name;
 	struct buffer *bp = (struct buffer *)0;
 
 	/* FQDN options have to be at least four bytes long. */
@@ -466,9 +458,7 @@
 	int priority_len;
 	unsigned char buffer [4096];	/* Really big buffer... */
 	unsigned main_buffer_size, mb_max;
-	unsigned mainbufix, bufix, agentix;
-	int fileix;
-	int snameix;
+	unsigned mainbufix, agentix;
 	unsigned option_size;
 	unsigned length;
 	int i;
@@ -476,7 +466,6 @@
 	struct data_string ds;
 	pair pp, *hash;
 	int need_endopt = 0;
-	int have_sso = 0;
 	int ocount = 0;
 	int ofbuf1=0, ofbuf2=0;
 
@@ -814,7 +803,6 @@
 	    if (u -> options [code] &&
 		((u -> options [code] -> format [0] == 'E' && !oc) ||
 		 u -> options [code] -> format [0] == 'e')) {
-		int uix;
 		static char *s, *t;
 		struct option_cache *tmp;
 		struct data_string name;
@@ -940,7 +928,6 @@
 	    toptstart = tix;
 	    while (length) {
 		    unsigned incr = length;
-		    int consumed = 0;
 		    int *pix;
 		    unsigned char *base;
 
@@ -1053,7 +1040,6 @@
 	const char *format;
 {
 	const char *p;
-	int retval = 0;
 
 	p = format;
 	while (*p != '\0') {
@@ -2006,7 +1992,6 @@
 {
 	pair ocp;
 	int status;
-	int i;
 	static struct option_cache *no_nwip;
 	struct data_string ds;
 	struct option_chain_head *head;
@@ -2020,7 +2005,6 @@
 
 	status = 0;
 	for (ocp = head -> first; ocp; ocp = ocp -> cdr) {
-		struct option_cache *oc = (struct option_cache *)(ocp -> car);
 		if (store_option (result, universe, packet,
 				  lease, client_state, in_options,
 				  cfg_options, scope,
@@ -2206,7 +2190,6 @@
 {
 	struct universe *universe = find_option_universe (oc -> option,
 							  vsname);
-	int i;
 
 	if (universe -> foreach)
 		(*universe -> foreach) (packet, lease, client_state,
@@ -2256,7 +2239,6 @@
 	struct option_cache *oc;
 {
 	pair *tail;
-	pair np = (pair )0;
 	struct option_chain_head *head;
 
 	if (universe -> index >= options -> universe_count)
@@ -2428,7 +2410,6 @@
 	struct iaddr from;
 	struct hardware *hfrom;
 {
-	int i;
 	struct option_cache *op;
 	struct packet *decoded_packet;
 #if defined (DEBUG_MEMORY_LEAKAGE)
--- dhcp-3.0.5/common/inet.c.warnings	2005-03-03 11:55:22.000000000 -0500
+++ dhcp-3.0.5/common/inet.c	2007-03-29 13:45:34.000000000 -0400
@@ -124,7 +124,7 @@
 	struct iaddr subnet;
 	struct iaddr mask;
 {
-	int i, j, k;
+	int i;
 	struct iaddr rv;
 
 	if (subnet.len > sizeof(subnet.iabuf))
--- dhcp-3.0.5/common/tree.c.warnings	2006-07-17 11:34:44.000000000 -0400
+++ dhcp-3.0.5/common/tree.c	2007-03-29 13:45:34.000000000 -0400
@@ -249,8 +249,6 @@
 	struct expression *expr;
 	int limit;
 {
-	struct expression *rv;
-
 	/* Allocate a node to enforce a limit on evaluation. */
 	if (!expression_allocate (new, MDL))
 		log_error ("no memory for limit expression");
@@ -644,11 +642,10 @@
 	struct binding_scope **scope;
 	struct expression *expr;
 {
-	ns_updrec *foo;
 	unsigned long ttl = 0;
 	char *tname;
 	struct data_string name, data;
-	int r0, r1, r2, r3;
+	int r0, r1, r2;
 
 	if (!result || *result) {
 		log_error ("evaluate_dns_expression called with non-null %s",
@@ -903,10 +900,7 @@
 	struct binding_scope **scope;
 	struct expression *expr;
 {
-	struct data_string left, right;
-	struct data_string rrtype, rrname, rrdata;
-	unsigned long ttl;
-	int srrtype, srrname, srrdata, sttl;
+	struct data_string left;
 	int bleft, bright;
 	int sleft, sright;
 	struct binding *binding;
@@ -1275,11 +1269,10 @@
 	int line;
 {
 	struct data_string data, other;
-	unsigned long offset, len, i;
+	unsigned long offset, len;
 	int s0, s1, s2, s3;
 	int status;
 	struct binding *binding;
-	char *s;
 	struct binding_value *bv;
 
 	switch (expr -> op) {
@@ -1826,7 +1819,6 @@
 					       MDL);
 
 		if (s0 && s1) {
-			char *upper;
 			int i;
 
 			/* The buffer must be a multiple of the number's
@@ -3127,8 +3119,6 @@
 int op_precedence (op1, op2)
 	enum expr_op op1, op2;
 {
-	int ov1, ov2;
-
 	return op_val (op1) - op_val (op2);
 }
 
@@ -3742,7 +3732,6 @@
 	const char *file;
 	int line;
 {
-	int i;
 	struct binding_scope *binding_scope;
 
 	if (!ptr || !*ptr) {
--- dhcp-3.0.5/common/alloc.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/alloc.c	2007-03-29 13:45:34.000000000 -0400
@@ -48,7 +48,6 @@
 	const char *file;
 	int line;
 {
-	int size;
 	struct option_chain_head *h;
 
 	if (!ptr) {
@@ -109,7 +108,6 @@
 	const char *file;
 	int line;
 {
-	int i;
 	struct option_chain_head *option_chain_head;
 	pair car, cdr;
 
@@ -161,7 +159,6 @@
 	const char *file;
 	int line;
 {
-	int size;
 	struct group *g;
 
 	if (!ptr) {
@@ -222,7 +219,6 @@
 	const char *file;
 	int line;
 {
-	int i;
 	struct group *group;
 
 	if (!ptr || !*ptr) {
@@ -745,8 +741,6 @@
 	const char *file;
 	int line;
 {
-	struct buffer *bp;
-
 	if (!ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -834,8 +828,6 @@
 	const char *file;
 	int line;
 {
-	struct dns_host_entry *bp;
-
 	if (!ptr || !*ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -1037,7 +1029,6 @@
 	const char *file;
 	int line;
 {
-	int size;
 	struct packet *p;
 
 	if (!ptr) {
@@ -1157,7 +1148,6 @@
 	const char *file;
 	int line;
 {
-	int size;
 	struct dns_zone *d;
 
 	if (!ptr) {
--- dhcp-3.0.5/common/dns.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/dns.c	2007-03-29 13:45:34.000000000 -0400
@@ -127,7 +127,6 @@
 isc_result_t find_tsig_key (ns_tsig_key **key, const char *zname,
 			    struct dns_zone *zone)
 {
-	isc_result_t status;
 	ns_tsig_key *tkey;
 
 	if (!zone)
@@ -201,7 +200,6 @@
 
 isc_result_t dns_zone_lookup (struct dns_zone **zone, const char *name)
 {
-	struct dns_zone *tz = (struct dns_zone *)0;
 	int len;
 	char *tname = (char *)0;
 	isc_result_t status;
@@ -234,7 +232,6 @@
 	const char *file;
 	int line;
 {
-	int i;
 	struct dns_zone *dns_zone;
 
 	if (!ptr || !*ptr) {
@@ -397,9 +394,7 @@
 void cache_found_zone (ns_class class,
 		       char *zname, struct in_addr *addrs, int naddrs)
 {
-	isc_result_t status = ISC_R_NOTFOUND;
 	struct dns_zone *zone = (struct dns_zone *)0;
-	struct data_string nsaddrs;
 	int ix = strlen (zname);
 
 	if (zname [ix - 1] == '.')
--- dhcp-3.0.5/common/resolv.c.warnings	2005-10-27 11:56:26.000000000 -0400
+++ dhcp-3.0.5/common/resolv.c	2007-03-29 13:45:34.000000000 -0400
@@ -50,10 +50,8 @@
 	struct parse *cfile;
 	const char *val;
 	int token;
-	int declaration = 0;
 	struct name_server *sp, *sl, *ns;
 	struct domain_search_list *dp, *dl, *nd;
-	struct iaddr *iaddr;
 
 	if ((file = open (path_resolv_conf, O_RDONLY)) < 0) {
 		log_error ("Can't open %s: %m", path_resolv_conf);
@@ -179,7 +177,6 @@
 
 struct name_server *first_name_server ()
 {
-	FILE *rc;
 	static TIME rcdate;
 	struct stat st;
 
@@ -190,8 +187,6 @@
 			return (struct name_server *)0;
 		}
 		if (st.st_mtime > rcdate) {
-			char rcbuf [512];
-			char *s, *t, *u;
 			rcdate = cur_time + 1;
 			
 			read_resolv_conf (rcdate);
--- dhcp-3.0.5/common/execute.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/execute.c	2007-03-29 13:45:34.000000000 -0400
@@ -54,8 +54,6 @@
 	struct executable_statement *r, *e, *next;
 	int rc;
 	int status;
-	unsigned long num;
-	struct binding_scope *outer;
 	struct binding *binding;
 	struct data_string ds;
 	struct binding_scope *ns;
@@ -283,7 +281,6 @@
 					binding -> next = (*scope) -> bindings;
 					(*scope) -> bindings = binding;
 				    } else {
-				       badalloc:
 					dfree (binding, MDL);
 					binding = (struct binding *)0;
 				    }
@@ -526,8 +523,6 @@
 	const char *file;
 	int line;
 {
-	struct executable_statement *bp;
-
 	if (!ptr || !*ptr) {
 		log_error ("%s(%d): null pointer", file, line);
 #if defined (POINTER_DEBUG)
@@ -650,8 +645,6 @@
 	int indent;
 {
 	struct executable_statement *r, *x;
-	int result;
-	int status;
 	const char *s, *t, *dot;
 	int col;
 
@@ -906,10 +899,8 @@
 {
 	int status, sub;
 	struct executable_statement *s;
-	unsigned long foo;
 
 	if (is_data_expression (expr)) {
-		struct executable_statement *e;
 		struct data_string cd, ds;
 		memset (&ds, 0, sizeof ds);
 		memset (&cd, 0, sizeof cd);
@@ -983,7 +974,6 @@
 {
 	struct executable_statement *foo;
 	int ok = 0;
-	int result;
 
 	for (foo = stmt; foo; foo = foo -> next) {
 	    if ((*callback) (foo, vp, condp) != 0)
--- dhcp-3.0.5/common/discover.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/discover.c	2007-03-29 13:45:34.000000000 -0400
@@ -124,16 +124,14 @@
 void discover_interfaces (state)
 	int state;
 {
-	struct interface_info *tmp, *ip;
+	struct interface_info *tmp;
 	struct interface_info *last, *next;
 	char buf [2048];
 	struct ifconf ic;
 	struct ifreq ifr;
 	int i;
 	int sock;
-	int address_count = 0;
 	struct subnet *subnet;
-	struct shared_network *share;
 	struct sockaddr_in foo;
 	int ir;
 	struct ifreq *tif;
@@ -435,7 +433,6 @@
 	for (tmp = interfaces; tmp; tmp = tmp -> next) {
 		struct ifreq ifr;
 		struct sockaddr sa;
-		int b, sk;
 		
 		if (!tmp -> ifp) {
 			/* Make up an ifreq structure. */
@@ -815,7 +812,6 @@
 {
 	struct interface_info *interface;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_interface)
 		return ISC_R_INVALIDARG;
@@ -858,7 +854,6 @@
 					 const char *file, int line)
 {
 	struct interface_info *interface;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_interface)
 		return ISC_R_INVALIDARG;
@@ -888,8 +883,6 @@
 					    const char *name, va_list ap)
 {
 	struct interface_info *ip, *interface;
-	struct client_config *config;
-	struct client_state *client;
 	isc_result_t status;
 
 	if (h -> type != dhcp_type_interface)
--- dhcp-3.0.5/common/comapi.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/common/comapi.c	2007-03-29 13:45:34.000000000 -0400
@@ -143,7 +143,6 @@
 {
 	struct group_object *group;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -217,7 +216,6 @@
 {
 	struct group_object *group;
 	isc_result_t status;
-	struct data_string ip_addrs;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -240,7 +238,6 @@
 isc_result_t dhcp_group_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct group_object *group, *t;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_group)
 		return ISC_R_INVALIDARG;
@@ -271,7 +268,7 @@
 isc_result_t dhcp_group_signal_handler (omapi_object_t *h,
 					const char *name, va_list ap)
 {
-	struct group_object *group, *t;
+	struct group_object *group;
 	isc_result_t status;
 	int updatep = 0;
 
@@ -453,7 +450,6 @@
 {
 	dhcp_control_object_t *control;
 	isc_result_t status;
-	int foo;
 	unsigned long newstate;
 
 	if (h -> type != dhcp_type_control)
@@ -488,7 +484,6 @@
 {
 	dhcp_control_object_t *control;
 	isc_result_t status;
-	struct data_string ip_addrs;
 
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
@@ -511,9 +506,6 @@
 isc_result_t dhcp_control_destroy (omapi_object_t *h,
 				   const char *file, int line)
 {
-	dhcp_control_object_t *control, *t;
-	isc_result_t status;
-
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
 
@@ -524,9 +516,8 @@
 isc_result_t dhcp_control_signal_handler (omapi_object_t *h,
 					const char *name, va_list ap)
 {
-	dhcp_control_object_t *control, *t;
+	dhcp_control_object_t *control;
 	isc_result_t status;
-	int updatep = 0;
 
 	if (h -> type != dhcp_type_control)
 		return ISC_R_INVALIDARG;
@@ -580,7 +571,6 @@
 {
 	omapi_value_t *tv = (omapi_value_t *)0;
 	isc_result_t status;
-	dhcp_control_object_t *control;
 
 	/* First see if we were sent a handle. */
 	if (ref) {
@@ -629,7 +619,6 @@
 {
 	struct subnet *subnet;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_subnet)
 		return ISC_R_INVALIDARG;
@@ -675,7 +664,6 @@
 isc_result_t dhcp_subnet_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct subnet *subnet;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_subnet)
 		return ISC_R_INVALIDARG;
@@ -752,10 +740,6 @@
 				 omapi_object_t *id,
 				 omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct subnet *subnet;
-
 	/* Can't look up subnets yet. */
 
 	/* If we get to here without finding a subnet, no valid key was
@@ -784,7 +768,6 @@
 {
 	struct shared_network *shared_network;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_shared_network)
 		return ISC_R_INVALIDARG;
@@ -832,7 +815,6 @@
 					  const char *file, int line)
 {
 	struct shared_network *shared_network;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_shared_network)
 		return ISC_R_INVALIDARG;
@@ -922,10 +904,6 @@
 					 omapi_object_t *id,
 					 omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct shared_network *shared_network;
-
 	/* Can't look up shared_networks yet. */
 
 	/* If we get to here without finding a shared_network, no valid key was
--- dhcp-3.0.5/dhcpctl/dhcpctl.c.warnings	2004-06-10 13:59:24.000000000 -0400
+++ dhcp-3.0.5/dhcpctl/dhcpctl.c	2007-03-29 14:25:41.000000000 -0400
@@ -101,7 +101,6 @@
 				dhcpctl_handle authinfo)
 {
 	isc_result_t status;
-	dhcpctl_status waitstatus;
 
 	status = omapi_generic_new (connection, MDL);
 	if (status != ISC_R_SUCCESS) {
@@ -171,7 +170,6 @@
 {
 	isc_result_t status;
 	omapi_value_t *tv = (omapi_value_t *)0;
-	omapi_data_string_t *value = (omapi_data_string_t *)0;
 	unsigned len;
 	int ip;
 
@@ -263,7 +261,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -297,7 +294,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -386,7 +382,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -416,7 +411,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *name = (omapi_data_string_t *)0;
-	int len;
 
 	status = omapi_data_string_new (&name, strlen (value_name), MDL);
 	if (status != ISC_R_SUCCESS)
--- dhcp-3.0.5/dhcpctl/callback.c.warnings	2004-06-10 13:59:23.000000000 -0400
+++ dhcp-3.0.5/dhcpctl/callback.c	2007-03-29 14:25:57.000000000 -0400
@@ -59,7 +59,6 @@
 {
 	dhcpctl_callback_object_t *callback;
 	omapi_object_t *inner;
-	isc_result_t status;
 
 	callback = dmalloc (sizeof *callback, MDL);
 	if (!callback)
@@ -162,8 +161,6 @@
 					    omapi_object_t *id,
 					    omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcpctl_callback_type)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/dhcpctl/remote.c.warnings	2004-06-10 13:59:24.000000000 -0400
+++ dhcp-3.0.5/dhcpctl/remote.c	2007-03-29 14:26:07.000000000 -0400
@@ -354,8 +354,6 @@
 					  omapi_object_t *id,
 					  omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcpctl_remote_type)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/dhcpctl/omshell.c.warnings	2005-10-27 11:56:26.000000000 -0400
+++ dhcp-3.0.5/dhcpctl/omshell.c	2007-03-29 14:26:36.000000000 -0400
@@ -82,11 +82,9 @@
 	dhcpctl_handle connection;
 	dhcpctl_handle authenticator;
 	dhcpctl_handle oh;
-	dhcpctl_data_string cid, ip_addr;
-	dhcpctl_data_string result, groupname, identifier;
 	struct data_string secret;
 	const char *name = 0, *algorithm = "hmac-md5";
-	int i, j;
+	int i;
 	int port = 7911;
 	const char *server = "127.0.0.1";
 	struct parse *cfile;
@@ -481,7 +479,6 @@
 				val = buf;
 				do {
 				    int intval = atoi (val);
-				dotiszero:
 				    if (intval > 255) {
 					parse_warn (cfile,
 						    "dotted octet > 255: %s",
--- dhcp-3.0.5/dhcpctl/cltest.c.warnings	2004-06-10 13:59:23.000000000 -0400
+++ dhcp-3.0.5/dhcpctl/cltest.c	2007-03-29 14:27:01.000000000 -0400
@@ -60,9 +60,8 @@
 	isc_result_t status, waitstatus;
 	dhcpctl_handle authenticator;
 	dhcpctl_handle connection;
-	dhcpctl_handle host_handle, group_handle, interface_handle;
-	dhcpctl_data_string cid;
-	dhcpctl_data_string result, groupname, identifier;
+	dhcpctl_handle interface_handle;
+	dhcpctl_data_string result;
 	int i;
 	int mode = undefined;
 	const char *interface = 0;
--- dhcp-3.0.5/dst/dst_api.c.warnings	2001-02-22 02:22:08.000000000 -0500
+++ dhcp-3.0.5/dst/dst_api.c	2007-03-29 13:45:34.000000000 -0400
@@ -543,7 +543,8 @@
 		return (NULL);
 	}
 	/* read in the key string */
-	fgets(enckey, sizeof(enckey), fp);
+	if (fgets(enckey, sizeof(enckey), fp) == NULL)
+		return NULL;
 
 	/* If we aren't at end-of-file, something is wrong.  */
 	while ((c = getc(fp)) != EOF)
--- dhcp-3.0.5/dst/prandom.c.warnings	2001-02-22 02:22:09.000000000 -0500
+++ dhcp-3.0.5/dst/prandom.c	2007-03-29 13:45:34.000000000 -0400
@@ -335,7 +335,7 @@
 		cnt += do_time(work);
 	}
 	while ((n = fread(buffer, sizeof(char), sizeof(buffer), pipe)) > 0)
-		NULL; /* drain the pipe */
+		continue; /* drain the pipe */
 	pclose(pipe);
 	return (cnt);		/* read how many bytes where read in */
 }
--- dhcp-3.0.5/minires/res_mkupdate.c.warnings	2004-06-10 13:59:43.000000000 -0400
+++ dhcp-3.0.5/minires/res_mkupdate.c	2007-03-29 13:45:34.000000000 -0400
@@ -108,7 +108,7 @@
 	u_int16_t rtype, rclass;
 	u_int32_t n1, rttl;
 	u_char *dnptrs[20], **dpp, **lastdnptr;
-	unsigned siglen, certlen;
+	unsigned certlen;
 	int keylen;
 	unsigned buflen = *blp;
 	u_char *buf = (unsigned char *)bp;
--- dhcp-3.0.5/minires/res_update.c.warnings	2004-06-10 13:59:44.000000000 -0400
+++ dhcp-3.0.5/minires/res_update.c	2007-03-29 13:45:34.000000000 -0400
@@ -88,7 +88,7 @@
 	double answer[PACKETSZ / sizeof (double)];
 	double packet[2*PACKETSZ / sizeof (double)];
 	struct zonegrp *zptr, tgrp;
-	int nzones = 0, nscount = 0;
+	int nscount = 0;
 	unsigned n;
 	unsigned rval;
 	struct sockaddr_in nsaddrs[MAXNS];
--- dhcp-3.0.5/omapip/protocol.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/protocol.c	2007-03-29 13:46:36.000000000 -0400
@@ -161,7 +161,6 @@
 	omapi_remote_auth_t *ra;
 	omapi_value_t *signature;
 	isc_result_t status;
-	u_int32_t foo;
 	unsigned auth_len;
 
 	if (po -> type != omapi_type_protocol ||
@@ -940,8 +939,6 @@
 					  omapi_object_t *id,
 					  omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != omapi_type_protocol)
 		return ISC_R_INVALIDARG;
 
@@ -1128,8 +1125,6 @@
 					    omapi_object_t *id,
 					    omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != omapi_type_protocol_listener)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/omapip/buffer.c.warnings	2005-10-06 15:05:46.000000000 -0400
+++ dhcp-3.0.5/omapip/buffer.c	2007-03-29 13:46:54.000000000 -0400
@@ -438,7 +438,6 @@
 	int bytes_written;
 	unsigned first_byte;
 	omapi_buffer_t *buffer;
-	unsigned char *bufp;
 	omapi_connection_object_t *c;
 	isc_result_t status;
 
@@ -575,7 +574,6 @@
 					  u_int32_t value)
 {
 	u_int32_t inbuf;
-	isc_result_t status;
 
 	inbuf = htonl (value);
 	
@@ -602,7 +600,6 @@
 					  u_int32_t value)
 {
 	u_int16_t inbuf;
-	isc_result_t status;
 
 	inbuf = htons (value);
 	
--- dhcp-3.0.5/omapip/alloc.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/alloc.c	2007-03-29 13:47:04.000000000 -0400
@@ -66,7 +66,6 @@
 {
 	unsigned char *foo;
 	unsigned len;
-	int i;
 	VOIDPTR *bar;
 #if defined (DEBUG_MEMORY_LEAKAGE) || defined (DEBUG_MALLOC_POOL) || \
 		defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
--- dhcp-3.0.5/omapip/connection.c.warnings	2004-11-24 12:39:17.000000000 -0500
+++ dhcp-3.0.5/omapip/connection.c	2007-03-29 13:47:35.000000000 -0400
@@ -111,10 +111,6 @@
 	omapi_connection_object_t *obj;
 	int flag;
 	struct sockaddr_in local_sin;
-#if defined (TRACING)
-	trace_addr_t *addrs;
-	u_int16_t naddrs;
-#endif
 
 	obj = (omapi_connection_object_t *)0;
 	status = omapi_connection_allocate (&obj, MDL);
@@ -1005,8 +1001,6 @@
 					    omapi_object_t *id,
 					    omapi_object_t *m)
 {
-	int i;
-
 	if (m -> type != omapi_type_connection)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/omapip/errwarn.c.warnings	2004-09-30 16:38:32.000000000 -0400
+++ dhcp-3.0.5/omapip/errwarn.c	2007-03-29 13:50:21.000000000 -0400
@@ -72,8 +72,10 @@
 
   /* Also log it to stderr? */
   if (log_perror) {
-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
-	  write (STDERR_FILENO, "\n", 1);
+	  if (write (STDERR_FILENO, mbuf, strlen (mbuf)) <= 0)
+	    return;
+	  if (write (STDERR_FILENO, "\n", 1) <= 0)
+	    return;
   }
 
 #if !defined (NOMINUM)
@@ -120,8 +122,10 @@
 #endif
 
   if (log_perror) {
-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
-	  write (STDERR_FILENO, "\n", 1);
+	  if (write (STDERR_FILENO, mbuf, strlen (mbuf)) <= 0)
+	    return 0;
+	  if (write (STDERR_FILENO, "\n", 1) <= 0)
+	    return 0;
   }
 
   return 0;
@@ -147,8 +151,10 @@
 #endif
 
   if (log_perror) {
-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
-	  write (STDERR_FILENO, "\n", 1);
+	  if (write (STDERR_FILENO, mbuf, strlen (mbuf)) <= 0)
+	    return 0;
+	  if (write (STDERR_FILENO, "\n", 1) <= 0)
+	    return 0;
   }
 
   return 0;
@@ -174,8 +180,10 @@
 #endif
 
   if (log_perror) {
-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
-	  write (STDERR_FILENO, "\n", 1);
+	  if (write (STDERR_FILENO, mbuf, strlen (mbuf)) <= 0)
+	    return 0;
+	  if (write (STDERR_FILENO, "\n", 1) <= 0)
+	    return 0;
   }
 
   return 0;
--- dhcp-3.0.5/omapip/listener.c.warnings	2004-06-10 13:59:48.000000000 -0400
+++ dhcp-3.0.5/omapip/listener.c	2007-03-29 13:50:51.000000000 -0400
@@ -68,12 +68,9 @@
 				omapi_addr_t *addr,
 				int max)
 {
-	struct hostent *he;
-	int hix;
 	isc_result_t status;
 	omapi_listener_object_t *obj;
 	int i;
-	struct in_addr ia;
 
 	/* Get the handle. */
 	obj = (omapi_listener_object_t *)0;
@@ -200,8 +197,6 @@
 	SOCKLEN_T len;
 	omapi_connection_object_t *obj;
 	omapi_listener_object_t *listener;
-	omapi_addr_t remote_addr;
-	int i;
 	struct sockaddr_in addr;
 	int socket;
 
@@ -223,7 +218,6 @@
 	/* If we're recording a trace, remember the connection. */
 	if (trace_record ()) {
 		trace_iov_t iov [3];
-		u_int32_t lsock;
 		iov [0].buf = (char *)&addr.sin_port;
 		iov [0].len = sizeof addr.sin_port;
 		iov [1].buf = (char *)&addr.sin_addr;
@@ -455,8 +449,6 @@
 					  omapi_object_t *id,
 					  omapi_object_t *l)
 {
-	int i;
-
 	if (l -> type != omapi_type_listener)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/omapip/generic.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/generic.c	2007-03-29 13:51:03.000000000 -0400
@@ -292,7 +292,6 @@
 isc_result_t omapi_generic_clear_flags (omapi_object_t *o)
 {
 	int i;
-	isc_result_t status;
 	omapi_generic_object_t *g;
 
 	if (o -> type != omapi_type_generic)
--- dhcp-3.0.5/omapip/support.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/support.c	2007-03-29 13:51:47.000000000 -0400
@@ -53,7 +53,6 @@
 
 omapi_object_type_t *omapi_object_types;
 int omapi_object_type_count;
-static int ot_max;
 
 #if defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
 void omapi_type_relinquish ()
@@ -298,7 +297,6 @@
 isc_result_t omapi_signal_in (omapi_object_t *handle, const char *name, ...)
 {
 	va_list ap;
-	omapi_object_t *outer;
 	isc_result_t status;
 
 	if (!handle)
@@ -368,7 +366,6 @@
 				  const char *name,
 				  omapi_typed_data_t *value)
 {
-	omapi_object_t *outer;
 	omapi_data_string_t *nds;
 	isc_result_t status;
 
@@ -389,8 +386,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -415,8 +410,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -441,8 +434,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
@@ -467,8 +458,6 @@
 	isc_result_t status;
 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
 	omapi_data_string_t *n = (omapi_data_string_t *)0;
-	int len;
-	int ip;
 
 	status = omapi_data_string_new (&n, strlen (name), MDL);
 	if (status != ISC_R_SUCCESS)
--- dhcp-3.0.5/omapip/handle.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/handle.c	2007-03-29 13:52:01.000000000 -0400
@@ -76,7 +76,6 @@
 
 isc_result_t omapi_object_handle (omapi_handle_t *h, omapi_object_t *o)
 {
-	int tabix;
 	isc_result_t status;
 
 	if (o -> handle) {
@@ -285,7 +284,6 @@
 isc_result_t omapi_handle_td_lookup (omapi_object_t **obj,
 				     omapi_typed_data_t *handle)
 {
-	isc_result_t status;
 	omapi_handle_t h;
 
 	if (handle -> type == omapi_datatype_int)
--- dhcp-3.0.5/omapip/message.c.warnings	2004-11-24 12:39:17.000000000 -0500
+++ dhcp-3.0.5/omapip/message.c	2007-03-29 13:52:15.000000000 -0400
@@ -209,8 +209,6 @@
 isc_result_t omapi_message_destroy (omapi_object_t *h,
 				    const char *file, int line)
 {
-	int i;
-
 	omapi_message_object_t *m;
 	if (h -> type != omapi_type_message)
 		return ISC_R_INVALIDARG;
@@ -261,8 +259,6 @@
 					 omapi_object_t *id,
 					 omapi_object_t *m)
 {
-	int i;
-
 	if (m -> type != omapi_type_message)
 		return ISC_R_INVALIDARG;
 
--- dhcp-3.0.5/omapip/convert.c.warnings	2004-11-24 12:39:17.000000000 -0500
+++ dhcp-3.0.5/omapip/convert.c	2007-03-29 13:52:32.000000000 -0400
@@ -165,7 +165,7 @@
 	u_int32_t number;
 	static char h2a [] = "0123456789abcdef";
 	int power = converted_length (inbuf, base, width);
-	int i, j;
+	int i;
 
 	if (base > 16)
 		return 0;
--- dhcp-3.0.5/omapip/hash.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/hash.c	2007-03-29 13:52:54.000000000 -0400
@@ -81,8 +81,6 @@
 	const char *file;
 	int line;
 {
-	int i;
-	struct hash_bucket *hbc, *hbn = (struct hash_bucket *)0;
 	struct hash_table *ptr = *tp;
 
 #if defined (DEBUG_MEMORY_LEAKAGE) || \
@@ -175,7 +173,6 @@
 	const char *file;
 	int line;
 {
-	struct hash_bucket *hp;
 #if defined (DEBUG_MALLOC_POOL)
 	for (hp = free_hash_buckets; hp; hp = hp -> next) {
 		if (hp == ptr) {
--- dhcp-3.0.5/omapip/array.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/array.c	2007-03-29 13:53:08.000000000 -0400
@@ -46,7 +46,6 @@
 				   omapi_array_deref_t deref,
 				   const char *file, int line)
 {
-	isc_result_t status;
 	omapi_array_t *aptr;
 
 	if (!array || *array)
@@ -63,7 +62,6 @@
 isc_result_t omapi_array_free (omapi_array_t **array,
 			       const char *file, int line)
 {
-	isc_result_t status;
 	omapi_array_t *aptr;
 	int i;
 
--- dhcp-3.0.5/omapip/trace.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/omapip/trace.c	2007-03-29 13:53:31.000000000 -0400
@@ -312,7 +312,7 @@
 				   void (*stop_tracing) (trace_type_t *),
 				   const char *file, int line)
 {
-	trace_type_t *ttmp, *tptr;
+	trace_type_t *ttmp;
 	unsigned slen = strlen (name);
 	isc_result_t status;
 
@@ -511,7 +511,6 @@
 	trace_type_t *ttype;
 	unsigned paylen;
 	int status;
-	int len;
 	fpos_t curpos;
 
 	status = fgetpos (traceinfile, &curpos);
@@ -637,7 +636,6 @@
 	unsigned bufmax = 0;
 	unsigned buflen = 0;
 	char *buf = (char *)0;
-	isc_result_t status;
 	time_t result;
 	trace_type_t *ttp;
 	
--- dhcp-3.0.5/omapip/mrtrace.c.warnings	2004-09-30 16:23:07.000000000 -0400
+++ dhcp-3.0.5/omapip/mrtrace.c	2007-03-29 13:53:49.000000000 -0400
@@ -85,7 +85,6 @@
 	unsigned buflen = 0;
 	char *buf = (char *)0;
 	isc_result_t status;
-	u_int32_t id;
 	int i;
 
 	if (trace_playback ()) {
@@ -412,7 +411,6 @@
 	isc_result_t status;
 
 	if (trace_playback ()) {
-		int nscount;
 		status = trace_get_packet (&trace_mr_randomid, &buflen, &buf);
 		if (status != ISC_R_SUCCESS) {
 			log_error ("trace_mr_statp: no statp packet found.");
--- dhcp-3.0.5/relay/dhcrelay.c.warnings	2006-04-27 17:38:30.000000000 -0400
+++ dhcp-3.0.5/relay/dhcrelay.c	2007-03-29 14:25:10.000000000 -0400
@@ -734,7 +734,7 @@
 	unsigned length;
 	struct in_addr giaddr;
 {
-	int is_dhcp = 0, agent_options_present = 0;
+	int is_dhcp = 0;
 	unsigned optlen;
 	u_int8_t *op, *nextop, *sp, *max, *end_pad = NULL;
 
--- dhcp-3.0.5/server/dhcpd.c.warnings	2006-07-17 11:23:44.000000000 -0400
+++ dhcp-3.0.5/server/dhcpd.c	2007-03-29 13:55:31.000000000 -0400
@@ -215,9 +215,6 @@
 	struct interface_info *ip;
 	struct parse *parse;
 	int lose;
-	omapi_object_t *auth;
-	struct tsig_key *key;
-	omapi_typed_data_t *td;
 	int no_dhcpd_conf = 0;
 	int no_dhcpd_db = 0;
 	int no_dhcpd_pid = 0;
@@ -551,7 +548,8 @@
 				if ((i = open (path_dhcpd_pid,
 					O_WRONLY | O_CREAT, 0644)) >= 0) {
 				    sprintf (pbuf, "%d\n", (int)getpid ());
-				    write (i, pbuf, strlen (pbuf));
+				    if (write (i, pbuf, strlen (pbuf)) <= 0)
+						exit(0);
 				    close (i);
 				    pidfilewritten = 1;
 				}
@@ -584,7 +582,8 @@
 		if ((i = open (path_dhcpd_pid,
 			       O_WRONLY | O_CREAT, 0644)) >= 0) {
 			sprintf (pbuf, "%d\n", (int)getpid ());
-			write (i, pbuf, strlen (pbuf));
+			if (write (i, pbuf, strlen (pbuf)) <= 0)
+				exit(0);
 			close (i);
 			pidfilewritten = 1;
 		}
@@ -974,7 +973,6 @@
 	   necessary. */
 	if (!ia) {
 		const char *fnn = "fallback-net";
-		char *s;
 		status = shared_network_allocate (&ip -> shared_network, MDL);
 		if (status != ISC_R_SUCCESS)
 			log_fatal ("No memory for shared subnet: %s",
--- dhcp-3.0.5/server/dhcp.c.warnings	2006-08-22 13:15:56.000000000 -0400
+++ dhcp-3.0.5/server/dhcp.c	2007-03-29 13:57:38.000000000 -0400
@@ -388,7 +388,6 @@
 	int ours = 0;
 	struct option_cache *oc;
 	struct data_string data;
-	int status;
 	char msgbuf [1024]; /* XXX */
 	const char *s;
 	char smbuf [19];
@@ -927,14 +926,13 @@
 	char msgbuf [1024];
 	struct data_string d1, prl;
 	struct option_cache *oc;
-	struct expression *expr;
 	struct option_state *options = (struct option_state *)0;
 	struct dhcp_packet raw;
 	struct packet outgoing;
 	unsigned char dhcpack = DHCPACK;
 	struct subnet *subnet = (struct subnet *)0;
 	struct iaddr cip, gip;
-	unsigned i, j;
+	unsigned i;
 	int nulltp;
 	struct sockaddr_in to;
 	struct in_addr from;
@@ -1308,7 +1306,6 @@
 	unsigned i;
 	struct data_string data;
 	struct option_state *options = (struct option_state *)0;
-	struct expression *expr;
 	struct option_cache *oc = (struct option_cache *)0;
 	struct iaddr myfrom;
 
@@ -1514,15 +1511,11 @@
 	TIME max_lease_time;
 	TIME default_lease_time;
 	struct option_cache *oc;
-	struct expression *expr;
-	int status;
 	isc_result_t result;
-	int did_ping = 0;
 	TIME ping_timeout;
 
 	unsigned i, j;
-	int s1, s2;
-	int val;
+	int s1;
 	int ignorep;
 
 	/* If we're already acking this lease, don't do it again. */
@@ -2742,12 +2735,9 @@
 	struct in_addr from;
 	struct hardware hto;
 	int result;
-	int i;
 	struct lease_state *state = lease -> state;
 	int nulltp, bootpp, unicastp = 1;
-	struct option_tag *ot, *not;
 	struct data_string d1;
-	struct option_cache *oc;
 	const char *s;
 
 	if (!state)
@@ -2968,7 +2958,6 @@
 	struct data_string d1;
 	int have_client_identifier = 0;
 	struct data_string client_identifier;
-	int status;
 	struct hardware h;
 
 	/* Quick check to see if the peer has leases. */
--- dhcp-3.0.5/server/confpars.c.warnings	2006-07-20 12:02:52.000000000 -0400
+++ dhcp-3.0.5/server/confpars.c	2007-03-29 14:01:32.000000000 -0400
@@ -329,15 +329,12 @@
 	enum dhcp_token token;
 	const char *val;
 	struct shared_network *share;
-	char *t, *n;
-	struct expression *expr;
-	struct data_string data;
+	char *n;
 	struct hardware hardware;
 	struct executable_statement *et, *ep;
 	struct option *option;
 	struct option_cache *cache;
 	int lose;
-	struct data_string key_id;
 	int known;
 	isc_result_t status;
 
@@ -927,7 +924,6 @@
 					    "load balance settings.");
 			if (token != NUMBER) {
 				parse_warn (cfile, "expecting number");
-			      badsplit:
 				skip_to_rbrace (cfile, 1);
 				dhcp_failover_state_dereference (&peer, MDL);
 				return;
@@ -1531,8 +1527,6 @@
 
 	/* See if there's already a pool into which we can merge this one. */
 	for (pp = pool -> shared_network -> pools; pp; pp = pp -> next) {
-		struct lease *l;
-
 		if (pp -> group -> statements != pool -> group -> statements)
 			continue;
 #if defined (FAILOVER_PROTOCOL)
@@ -1843,7 +1837,6 @@
 	char *name;
 	const char *tname;
 	struct executable_statement *stmt = (struct executable_statement *)0;
-	struct expression *expr;
 	int new = 1;
 	isc_result_t status = ISC_R_FAILURE;
 
@@ -2252,7 +2245,6 @@
 	unsigned char addr [4];
 	unsigned len = sizeof addr;
 	int declaration = 0;
-	struct interface_info *ip;
 	isc_result_t status;
 
 	subnet = (struct subnet *)0;
@@ -2546,8 +2538,6 @@
 	char tbuf [32];
 	struct lease *lease;
 	struct executable_statement *on;
-	struct expression *exp;
-	struct data_string ds;
 	int lose;
 	TIME t;
 	char *s;
@@ -2973,7 +2963,6 @@
 
 			token = peek_token (&val, (unsigned *)0, cfile);
 			if (token == STRING) {
-			    unsigned char *tuid;
 			    token = next_token (&val, &buflen, cfile);
 			    binding -> value -> type = binding_data;
 			    binding -> value -> value.data.len = buflen;
@@ -3130,7 +3119,6 @@
 	int dynamic = 0;
 	struct subnet *subnet;
 	struct shared_network *share;
-	struct pool *p;
 	struct pool *pool;
 	isc_result_t status;
 
--- dhcp-3.0.5/server/db.c.warnings	2006-07-19 12:45:30.000000000 -0400
+++ dhcp-3.0.5/server/db.c	2007-03-29 14:02:00.000000000 -0400
@@ -56,7 +56,6 @@
 	struct tm *t;
 	char tbuf [64];
 	int errors = 0;
-	int i;
 	struct binding *b;
 	char *s;
 
@@ -199,7 +198,6 @@
 		}
 	}
 	if (lease -> uid_len) {
-		int i;
 		s = quotify_buf (lease -> uid, lease -> uid_len, MDL);
 		if (s) {
 			fprintf (db_file, "\n  uid \"%s\";", s);
@@ -467,7 +465,6 @@
 	struct group_object *group;
 {
 	int errors = 0;
-	int i;
 
 	/* If the lease file is corrupt, don't try to write any more leases
 	   until we've written a good lease file. */
@@ -625,8 +622,6 @@
 {
 	struct collection *lp;
 	struct class *cp;
-	struct hash_bucket *bp;
-	int i;
 
 	for (lp = collections; lp; lp = lp -> next) {
 	    for (cp = lp -> classes; cp; cp = cp -> nic) {
--- dhcp-3.0.5/server/failover.c.warnings	2006-09-22 12:29:44.000000000 -0400
+++ dhcp-3.0.5/server/failover.c	2007-03-29 14:19:10.000000000 -0400
@@ -57,7 +57,6 @@
 {
 	dhcp_failover_state_t *state;
 	isc_result_t status;
-	dhcp_failover_listener_t *l;
 
 	for (state = failover_states; state; state = state -> next) {
 		dhcp_failover_state_transition (state, "startup");
@@ -174,7 +173,6 @@
 {
 	isc_result_t status;
 	dhcp_failover_link_t *obj;
-	omapi_value_t *value = (omapi_value_t *)0;
 	dhcp_failover_state_t *state;
 	omapi_object_t *o;
 	int i;
@@ -276,8 +274,6 @@
 	isc_result_t status;
 	dhcp_failover_link_t *link;
 	omapi_object_t *c;
-	u_int16_t nlen;
-	u_int32_t vlen;
 	dhcp_failover_state_t *s, *state = (dhcp_failover_state_t *)0;
 
 	if (h -> type != dhcp_type_failover_link) {
@@ -591,7 +587,6 @@
 	unsigned op_size;
 	unsigned op_count;
 	int i;
-	isc_result_t status;
 	
 	if (link -> imsg_count + 2 > link -> imsg_len) {
 		log_error ("FAILOVER: message overflow at option code.");
@@ -1121,8 +1116,6 @@
 					   omapi_object_t *id,
 					   omapi_object_t *p)
 {
-	int i;
-
 	if (p -> type != dhcp_type_failover_listener)
 		return ISC_R_INVALIDARG;
 
@@ -1182,11 +1175,8 @@
 					 const char *name, va_list ap)
 {
 	isc_result_t status;
-	omapi_connection_object_t *c;
-	omapi_protocol_object_t *obj;
 	dhcp_failover_state_t *state;
 	dhcp_failover_link_t *link;
-	char *peer_name;
 
 	if (!o || o -> type != dhcp_type_failover_state)
 		return ISC_R_INVALIDARG;
@@ -1831,7 +1821,6 @@
 	enum failover_state previous_state = state -> partner.state;
 	enum failover_state new_state;
 	int startupp;
-	isc_result_t status;
 
 	new_state = msg -> server_state;
 	startupp = (msg -> server_flags & FTF_STARTUP) ? 1 : 0;
@@ -2185,7 +2174,6 @@
 	struct lease *next = (struct lease *)0;
 	struct shared_network *s;
 	struct pool *p;
-	int polarity;
 	binding_state_t peer_lease_state;
 	binding_state_t my_lease_state;
 	struct lease **lq;
@@ -2328,7 +2316,6 @@
 
 int dhcp_failover_state_pool_check (dhcp_failover_state_t *state)
 {
-	struct lease *lp;
 	struct shared_network *s;
 	struct pool *p;
 
@@ -2647,7 +2634,7 @@
 
 void dhcp_failover_keepalive (void *vs)
 {
-	dhcp_failover_state_t *state = vs;
+	return;
 }
 
 void dhcp_failover_reconnect (void *vs)
@@ -2681,8 +2668,6 @@
 void dhcp_failover_startup_timeout (void *vs)
 {
 	dhcp_failover_state_t *state = vs;
-	isc_result_t status;
-
 #if defined (DEBUG_FAILOVER_TIMING)
 	log_info ("dhcp_failover_startup_timeout");
 #endif
@@ -2693,7 +2678,6 @@
 void dhcp_failover_link_startup_timeout (void *vl)
 {
 	dhcp_failover_link_t *link = vl;
-	isc_result_t status;
 	omapi_object_t *p;
 
 	for (p = (omapi_object_t *)link; p -> inner; p = p -> inner)
@@ -3172,7 +3156,6 @@
 int dhcp_failover_state_match (dhcp_failover_state_t *state,
 			       u_int8_t *addr, unsigned addrlen)
 {
-	struct option_cache *oc;
 	struct data_string ds;
 	int i;
 	
@@ -3709,7 +3692,6 @@
 					omapi_object_t *connection,
 					int msg_type, ...)
 {
-	unsigned count = 0;
 	unsigned size = 0;
 	int bad_option = 0;
 	int opix = 0;
@@ -3822,7 +3804,6 @@
 {
 	dhcp_failover_state_t *state = vstate;
 	dhcp_failover_link_t *link;
-	isc_result_t status;
 
 #if defined (DEBUG_FAILOVER_TIMING)
 	log_info ("dhcp_failover_timeout");
@@ -3942,7 +3923,6 @@
 	dhcp_failover_link_t *link;
 	dhcp_failover_state_t *state;
 	isc_result_t status;
-	char hba [32];
 #if defined (DEBUG_FAILOVER_MESSAGES)	
 	char obuf [64];
 	unsigned obufix = 0;
--- dhcp-3.0.5/server/omapi.c.warnings	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/server/omapi.c	2007-03-29 14:20:32.000000000 -0400
@@ -208,7 +208,6 @@
 {
 	struct lease *lease;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -378,7 +377,6 @@
 isc_result_t dhcp_lease_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct lease *lease;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -455,7 +453,6 @@
 {
 	struct lease *lease;
 	isc_result_t status;
-	int updatep = 0;
 
 	if (h -> type != dhcp_type_lease)
 		return ISC_R_INVALIDARG;
@@ -876,9 +873,8 @@
 				   omapi_data_string_t *name,
 				   omapi_typed_data_t *value)
 {
-	struct host_decl *host, *hp;
+	struct host_decl *host;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_host)
 		return ISC_R_INVALIDARG;
@@ -1137,7 +1133,6 @@
 isc_result_t dhcp_host_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct host_decl *host;
-	isc_result_t status;
 
 	if (h -> type != dhcp_type_host)
 		return ISC_R_INVALIDARG;
@@ -1558,7 +1553,6 @@
 {
 	struct pool *pool;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_pool)
 		return ISC_R_INVALIDARG;
@@ -1604,8 +1598,6 @@
 isc_result_t dhcp_pool_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct pool *pool;
-	isc_result_t status;
-	struct permit *pc, *pn;
 
 	if (h -> type != dhcp_type_pool)
 		return ISC_R_INVALIDARG;
@@ -1702,10 +1694,6 @@
 isc_result_t dhcp_pool_lookup (omapi_object_t **lp,
 			       omapi_object_t *id, omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct pool *pool;
-
 	/* Can't look up pools yet. */
 
 	/* If we get to here without finding a pool, no valid key was
@@ -1734,7 +1722,6 @@
 {
 	struct class *class;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_class)
 		return ISC_R_INVALIDARG;
@@ -1780,8 +1767,6 @@
 isc_result_t dhcp_class_destroy (omapi_object_t *h, const char *file, int line)
 {
 	struct class *class;
-	isc_result_t status;
-	int i;
 
 	if (h -> type != dhcp_type_class && h -> type != dhcp_type_subclass)
 		return ISC_R_INVALIDARG;
@@ -1881,10 +1866,6 @@
 isc_result_t dhcp_class_lookup (omapi_object_t **lp,
 				omapi_object_t *id, omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct class *class;
-
 	/* Can't look up classs yet. */
 
 	/* If we get to here without finding a class, no valid key was
@@ -1913,7 +1894,6 @@
 {
 	struct subclass *subclass;
 	isc_result_t status;
-	int foo;
 
 	if (h -> type != dhcp_type_subclass)
 		return ISC_R_INVALIDARG;
@@ -2008,10 +1988,6 @@
 isc_result_t dhcp_subclass_lookup (omapi_object_t **lp,
 				   omapi_object_t *id, omapi_object_t *ref)
 {
-	omapi_value_t *tv = (omapi_value_t *)0;
-	isc_result_t status;
-	struct subclass *subclass;
-
 	/* Can't look up subclasss yet. */
 
 	/* If we get to here without finding a subclass, no valid key was
--- dhcp-3.0.5/server/mdb.c.warnings	2006-07-18 14:16:25.000000000 -0400
+++ dhcp-3.0.5/server/mdb.c	2007-03-29 14:21:32.000000000 -0400
@@ -238,7 +238,6 @@
 	struct host_decl *hp = (struct host_decl *)0;
 	struct host_decl *np = (struct host_decl *)0;
 	struct host_decl *foo;
-	struct executable_statement *esp;
 	int hw_head = 0, uid_head = 1;
 
 	/* Don't need to do it twice. */
@@ -373,7 +372,6 @@
 			 const unsigned char *haddr, unsigned hlen,
 			 const char *file, int line)
 {
-	struct host_decl *foo;
 	struct hardware h;
 
 	h.hlen = hlen + 1;
@@ -403,7 +401,6 @@
 			   struct iaddr *addr, struct shared_network *share)
 {
 	int i;
-	struct subnet *subnet;
 	struct iaddr ip_address;
 	struct host_decl *hp;
 	struct data_string fixed_addr;
@@ -453,12 +450,11 @@
 	struct pool *pool;
 	struct lease **lpchain;
 {
-	struct lease *address_range, *lp, *plp;
+	struct lease *address_range;
 	struct iaddr net;
 	unsigned min, max, i;
 	char lowbuf [16], highbuf [16], netbuf [16];
 	struct shared_network *share = subnet -> shared_network;
-	isc_result_t status;
 	struct lease *lt = (struct lease *)0;
 
 	/* All subnets should have attached shared network structures. */
@@ -745,7 +741,6 @@
 	struct lease *lease;
 {
 	struct lease *comp = (struct lease *)0;
-	isc_result_t status;
 
 	if (find_lease_by_ip_addr (&comp, lease -> ip_addr, MDL)) {
 		if (!comp -> pool) {
@@ -795,7 +790,6 @@
 	int enter_uid = 0;
 	int enter_hwaddr = 0;
 	struct lease *lp, **lq, *prev;
-	TIME lp_next_state;
 
 #if defined (FAILOVER_PROTOCOL)
 	/* We must commit leases before sending updates regarding them
@@ -1475,7 +1469,6 @@
 	void *vpool;
 {
 	struct pool *pool;
-	struct lease *lt = (struct lease *)0;
 	struct lease *next = (struct lease *)0;
 	struct lease *lease = (struct lease *)0;
 	struct lease **lptr [5];
@@ -2013,7 +2006,6 @@
 {
 	struct shared_network *s;
 	struct pool *p;
-	struct hash_bucket *hb;
 	int i;
 	struct lease *l;
 	struct lease **lptr [5];
--- dhcp-3.0.5/server/ddns.c.warnings	2005-03-03 11:55:24.000000000 -0500
+++ dhcp-3.0.5/server/ddns.c	2007-03-29 14:21:51.000000000 -0400
@@ -224,7 +224,6 @@
 	struct data_string ddns_fwd_name;
 	struct data_string ddns_rev_name;
 	struct data_string ddns_dhcid;
-	unsigned len;
 	struct data_string d1;
 	struct option_cache *oc;
 	int s1, s2;
@@ -659,7 +658,6 @@
 	struct data_string ddns_rev_name;
 	struct data_string ddns_dhcid;
 	isc_result_t rcode;
-	struct binding *binding;
 	int result = 0;
 	int client_updated = 0;
 
